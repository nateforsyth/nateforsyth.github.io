---
layout: post
title: The start of PetrolIQ, ASP.NET Core with a React front-end - (kinda) part 2, Rolling your own Auth. Learnings, trials, tribulations and... wins?
date: 2024-01-24 +13:00
published: false
category: Dev
tags: [petroliq, asp.net core, web api, httponly cookies, jwt, passport auth, learnings, mongodb]
---

A very long time ago, I started (and abandoned) a series about ASP.NET development, titled [Modernising a legacy application using ASP.NET 4.8, JWT, SQL Server, Entity Framework Data First and a React front-end - part 1](https://dreamsof.dev/2020-07-22-modernising-legacy-app-aspnet48-jwt-sql-efdatafirst-react-1/). Within that post, I began the process of updating an fictional pseudo-legacy ASP.NET Framework application to ASP.NET 4.8. I implemented Entity Framework data-first migrations and implemented JWT token authentication. And that's where I left it - I got busy.

# Needs must

Fast forward 3 1/2 years (wow), and I've lost my job. That time spent behind a corporate NDA means I don't have much to show for my time at the old company.

I've had a passion project in my periphery for the better part of 7 years, with not a lot of time to work on it. This is PetrolIQ. There will be other posts about that, but not yet.

Now's the time, but first, I had to scaffold the basics.

# A new project

I've spent the last 3 weeks implementing the basics for the project using an ASP.NET Core Web API. There was a caveat; I am an avid home-labber, so everything needed to be self-hosted in my garage on my 1U HPE server.

I needed/wanted to use the following:

* A database.
  * I chose MongoDB because I've never worked with it before.
* Passport auth.
  * Authentication with RBAC.
* ASP.NET Core 8


# Self hosting

As mentioned, I have a home lab. I am currently using Windows Server 2019 on bare-metal, which is running Hyper-V. I have a VM also running Windows Server 2019, configured with IIS running all of my web projects. There are other VMs running irrelevant things, however one important one is running a free [Kemp Load Balancer](https://freeloadbalancer.com/).

The server itself is an [HPE ProLiant DL360 G7 Server](https://support.hpe.com/hpesc/public/docDisplay?docId=c02206768&docLocale=en_US) which has 2x 6 core (12 thread) Intel Xeon E5645 CPUs, 96GB of DDR3 RAM and 4x 300GB 10k SAS HDDs running in RAID 1 (system and data drives).

The Load Balancer allows for me to use a single TLD with subdomains to send all secure traffic to my home (static) IP address and direct it to whichever internal IP address is required for a specific service. This is used in conjunction with a Cloudflare proxy.

I currently have MongoDB running on bare metal alongside Hyper-V (will eventually be moved to a Docker container).

The Web API and React front-end are running on the IIS VM.

# Project structure

The Petroliq solution is currently synced to a public Github repository. I'm a little precious about the PetroliqAlgorithm so that's private. 

```
ðŸ“¦ ./
â”œâ”€Â Petroliq
â”‚Â Â â”œâ”€Â Petroliq_API
â”‚Â Â â””â”€Â React
â””â”€Â PetroliqAlgorithm
```
Â©generated by [Project Tree Generator](https://woochanleee.github.io/project-tree-generator)


## A database

As mentioned previously; I have MongoDB running on bare metal. The schema of which is manually maintained.

## Passport Auth

I originally implemented storage of the JWT in localStorage (prior to pushing it to the host), just to get it working. I knew that was insecure so I spent **many** hours researching how best to handle it.

To preface; yes, I've rolled my own auth. This was important as I wanted a deep dive into how to do so.

I feel something isn't right with the implementation I've gone with - please feel free to pick it apart (this may be **completely irrelevant** now that Google has announced 3rd party token deprecation this year).

I settled on the following:

* Upon initial authorisation.
   * Generate a refresh token.
      * Save that refresh token to the Users' database record.
   * Set HttpOnly cookies with.
      * Access token.
      * Refresh token.
   * Hash the refresh token.
   * In the returned payload, provide.
      * User Id.
      * Expiry date of the Access token.
      * **Hashed** Refresh token.

The point of this is to:

* Ensure that the access token is never sent back to the browser in the returned payload.
* The reason for the hashed refresh token being sent back is because it's compared with the non-hashed version to detect modification.
   * It's validated against the one in the HttpOnly cookie for subsequent API calls, and what's stored in the database for the User.
* The reason that the UserId is sent back is to persist it for the user when they need to refresh their Access token.

# Questions

I feel like I shouldn't be passing the UserId *and* Refresh token back in the same response.

* How's my implementation?
   * Should the (hashed) Refresh token include the UserId?

# Implementation

I'm not treating this as a tutorial, therefore I will highlight key configuration details specifically for problems or considerations I encountered.

## CORS

CORS was always going to be a consideration throughout the build process, so I ended up configuring CORS as follows.

~~~cs
// ./Petroliq_API/Program.cs
public class Program
{
    public static void Main(string[] args)
    {
        // previous elided for brevity

        builder.Services.AddCors(options =>
        {
            options.AddPolicy("_Auth", policy =>
            {
                policy
                    .WithOrigins(
                        "http://localhost:3000",
                        [public end-points elided]
                    )
                    .AllowAnyMethod()
                    .AllowAnyHeader()
                    .SetPreflightMaxAge(TimeSpan.FromSeconds(3600))
                    .AllowCredentials();
            });
        });

        // remainder elided for brevity
    }
}
~~~

## Passport Auth

Due to my requirement for running this service on my own server, and having chosen IIS to do so, there were some funky issues encountered when using `User Secrets`, namely that it ended up causing me to scratch my head a little too much while attempting to target environment variables across IIS Application Pools.

Here is the structure of the `secrets.json` file.

~~~json
./Petroliq_API/secrets.json
{
  "ConnectionString": "[elided]",
  "AuthKey": "[elided]"
}
~~~

And here is the structure of the `appsettings.json` file; note that there is crossover in these settings.

* secrets/ConnectionString >> appsettings/PetroliqDatabase/ConnectionString
* secrets/AuthKey >> appsettings/PetroliqDatabase/Auth:Key

~~~json
./Petroliq_API/appsettings.json
{
  "PetroliqDatabase": {
    "ConnectionString": "REPLACE_ME_REFER_README",
    "DatabaseName": "Petroliq",
    "UserSettingsCollectionName": "UserSettings",
    "UsersCollectionName": "Users"
  },
  "Auth": {
    "Audience": "[elided]/api",
    "Key": "REPLACE_ME_REFER_README",
    "Issuer": "[elided]",
    "TokenValidityMinutes": 5,
    "RefreshTokenValiditityDays":  7
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "Petroliq": {
    "KM_MI_FACTOR": 1.60934,
    "MI_KM_FACTOR": 0.62,
    "LTR_GAL_FACTOR": 4.54609,
    "DEFAULT_ROUND_TO": 2
  },
  "AllowedHosts": "*"
}
~~~

As previously eluded to, I encountered problems that blocked me more than I'd liked, therefore I resigned myself to using both `secrets.json` (in development) and `appsettings.json` (in "production"). Note the preprocessor directive in the snippet below.

~~~cs
// ./Petroliq_API/Program.cs
public class Program
{
    public static void Main(string[] args)
    {
        // previous elided for brevity

        #region Configure Auth
        string? jwtIssuer = string.Empty;
        string? jwtKey = string.Empty;
        string? jwtAudience = string.Empty;
        int? cookieTokenValidityMinutes = 5; // default, overridden by app settings
#if !DEBUG
        // from appsettings.json, for IIS usage
        jwtIssuer = authSettings.GetSection("Issuer").Value; // builder.Configuration["Auth:Issuer"];
        jwtKey = authSettings.GetSection("Key").Value;
        jwtAudience = authSettings.GetSection("Audience").Value;
        if (int.TryParse(authSettings.GetSection("TokenValidityMinutes").Value, out int cookieValidity))
        {
            cookieTokenValidityMinutes = cookieValidity;
        }
#else
        // from secrets.json, inaccessible when hosted on IIS
        jwtIssuer = builder.Configuration["Auth:Issuer"];
        jwtKey = builder.Configuration["AuthKey"];
        jwtAudience = builder.Configuration["Auth:Audience"];
        if (int.TryParse(builder.Configuration["Auth:TokenValidityMinutes"], out int cookieValidity))
        {
            cookieTokenValidityMinutes = cookieValidity;
        }
#endif

        if (!string.IsNullOrEmpty(jwtIssuer) && !string.IsNullOrEmpty(jwtKey) && !string.IsNullOrEmpty(jwtAudience))
        {
            builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
            .AddJwtBearer(options =>
            {
                options.TokenValidationParameters = new TokenValidationParameters
                {
                    ValidateIssuer = true,
                    ValidateAudience = true,
                    ValidateLifetime = true,
                    ValidateIssuerSigningKey = true,
                    ValidIssuer = jwtIssuer,
                    ValidAudience = jwtAudience,
                    IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtKey)),
                    ClockSkew = TimeSpan.Zero
                };

                options.Authority = jwtIssuer;

                // configure pipleline so that the HttpOnly cookie is provided to all end-points
                options.Events = new JwtBearerEvents
                {
                    OnMessageReceived = context =>
                    {
                        if (context.Request.Cookies.ContainsKey("X-Access-Token"))
                        {
                            context.Token = context.Request.Cookies["X-Access-Token"];
                        }
                        return Task.CompletedTask;
                    },
                };
            });

            // configure RBAC roles for RoleHandler
            builder.Services.AddAuthorization(options =>
            {
                options.AddPolicy("admin", policy => policy.Requirements.Add(new HasRoleRequirement(jwtIssuer, ["administrator"])));
                options.AddPolicy("userAdmin", policy => policy.Requirements.Add(new HasRoleRequirement(jwtIssuer, ["administrator", "users.read", "users.write", "userSettings.read", "userSettings.write"])));
                options.AddPolicy("appUser", policy => policy.Requirements.Add(new HasRoleRequirement(jwtIssuer, ["appUser", "administrator", "users.read", "users.write", "userSettings.read", "userSettings.write"])));
            });

            builder.Services.AddSingleton<IAuthorizationHandler, HasRoleHandler>();
        }
        #endregion

        // remainder elided for brevity
    }
}
~~~
